## Http协议

### 持久连接节省通信量

##### 持久连接

持久连接（HTTP Persistent Connections，也称HTTP keep-alive或HTTP connect reuse)。持久连接的特点是，只要任意一端没有明确的提出断开连接，则保持TCP连接状态。

持久连接的好处在于减少了TCP连接的重复建立和断开造成的额外的开销，减轻了服务器的负载。这样Web页面的显示速度也就相应的提高了。

##### 管线化

持久连接使得多数请求以管线化(pipelining)方式成为可能。从前发送请求需等待响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。

这样就能够做到同时并行发送多个请求，而不需一个接一个的等待响应。

### 使用Cookie的状态管理

Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。

Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。

服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。

### HTTP报文

用于HTTP协议交互的信息被称为HTTP报文。请求端（客户端）的HTTP报文叫做请求报文，响应端（服务器端）的报文叫做响应报文。HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。

HTTP 报文大致可分为报文首部和报文主体两块。通常，并不一定有报文主体。

### 请求报文及响应报文的结构

**请求行**

用于请求的方法，请求的URI和HTTP版本

**状态行**

宝行表明响应结果的状态码，原因短语和HTTP版本。

**首部字段**

包含表示请求和响应的各种条件和属性的各类首部。

一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部

**其他**

可能包含HTTP的RPF中未定义的首部（cookie等）

### 编码提升传输速率

常用的内容编码：

* gzip(GNU zip)
* compress(UNIX系统的标准压缩)
* deflate(zlib)
* indentity(不进行编码)

#### 分块传输编码

### 发送多种数据的多部分对象集合

发送邮件时，我们可以在邮件里写入文字并添加多份附件。这是因为采用了 MIME（Multipurpose Internet Mail Extensions，多用途因特网邮件扩展）机制，它允许邮件处理文本、图片、视频等多个不同类型的数据。例如，图片等二进制数据以 ASCII 码字符串编码的方式指明，就是利用 MIME 来描述标记数据类型。而在 MIME 扩展中会使用一种称为多部分对象集合（Multipart）的方法，来容纳多份不同类型的数据。

相应地，HTTP 协议中也采纳了多部分对象集合，发送的一份报文主体内可含有多类型实体。通常是在图片或文本文件等上传时使用。

### 获取部分内容的范围请求

指定范围的发送请求叫做范围请求（Range Request)。

Range: bytes=5001-10000

### 内容协商

同一个Web网站可能存在着多份相同的内容页面。比如英语版和中文版的 Web 页面，它们内容上虽相同，但使用的语言却不同。

当浏览器的默认语言为英文或中文，访问相同的URI的Web页面时，会显示对应的英文版或者中文版的web页面。这样的机制称为内容协商。 

**判断基准**

• Accept

• Accept-Charset

• Accept-Encoding

• Accept-Language

• Content-Language

### 状态码告知从服务器端返回的请求结果

状态码的职责是当客户端向服务器端发送请求数据时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。

状态码类别

| 状态码 | 类别                           | 原因短语                   |
| ------ | ------------------------------ | -------------------------- |
| 1xx    | Informational(信息性状态码)    | 接受的请求正在处理         |
| 2xx    | Success(成功状态码)            | 接受的请求正常处理完毕     |
| 3xx    | Redirection(重定向状态码)      | 需要进行附加操作以完成请求 |
| 4xx    | Client Error(客户端错误状态码) | 服务器无法处理请求         |
| 5xx    | Server Error(服务器错误状态码) | 服务器处理错误             |

### 通信数据转发程序：代理、网关、隧道

#### 代理

代理是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接受由客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。

**缓存代理** 

代理转发时，缓存代理(Caching Proxy)会预先将资源的副本（缓存）保存在代理服务器上。而当代理再次接受到相同的资源请求的时，就可以不从原服务器那里获取资源，而是将之前的缓存的资源作为响应返回。

**透明代理**

转发代理请求和响应时，不对报文做任何加工的代理类型被称为透明代理(Transparent Proxy)。反之，对报文内容进行加工的代理被称为非透明代理。

#### 网关

网关是转发其他服务器通信数据的服务器，接受从客户端发送过来的请求时，他就像自己拥有资源的服务器一样对请求进行处理。有时客户端可能不会察觉，自己通信的目标是一个网关。

网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供非 HTTP 协议服务。利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

#### 隧道

隧道是在相隔甚远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。

### 缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可以减少对源服务器的访问，因此节省了通信流量和通信时间。

#### 缓存的有效期限

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失效，缓存服务器将会再次从源服务器上获取“新”资源。

#### 客户端缓存

缓存不仅可以存在于缓存服务器内，还可以存在客户端浏览器中。以 Internet Explorer 程序为例，把客户端缓存称为临时网络文件（Temporary Internet File）。

浏览器缓存如果有效，就不必再向服务器请求相同的资源了，可以直接从本地磁盘内读取。

### HTTP报文首部

HTTP协议的请求和响应报文中必定包含HTTP首部。首部内容为客户端和服务器分别处理请求和响应提供所需的信息。对于客户端来说，这些信息中的大部分内容都无需查看。

HTTP首部字段是构成HTTP报文的要素之一。在客户端和服务器之间以HTTP协议进行通信的过程，无论是请求还是响应都会使用首部字段，它能起到传递额外重要信息的作用。

使用首部字段是为了给浏览器和服务器提供报文主体大小、所使用的语言、认证信息等内容。

#### 四种HTTP首部字段

* 通用首部字段
* 请求首部字段
* 响应首部字段

#### 通用首部字段

| 首部字段名        | 说明                       |
| ----------------- | -------------------------- |
| Cache-Control     | 控制缓存行为               |
| Connection        | 逐跳首部、连接的管理       |
| Date              | 创建报文的日期时间         |
| Progma            | 报文指令                   |
| Trailer           | 报文末端的首部一览         |
| Transfer_Encoding | 指定报文主体的传输编码方式 |
| Upgrade           | 升级为其他协议             |
| Via               | 代理服务器的相关信息       |
| Warning           | 错误通知                   |

#### 请求首部字段

| 首部字段名          | 说明                                          |
| ------------------- | --------------------------------------------- |
| Accept              | 用户代理可处理的媒体类型                      |
| Accept-Charset      | 优先的字符串集                                |
| Accept-Encoding     | 优先的内容编码                                |
| Accept-Language     | 优先的语言（自然语言）                        |
| Authorization       | Web认证信息                                   |
| Expect              | 期待服务器的特定行为                          |
| From                | 用户的电子邮箱地址                            |
| Host                | 请求资源所在服务器                            |
| If-match            | 比较实体标记（ETag）                          |
| If-Modified-Since   | 比较资源的更新时间                            |
| If-None_Match       | 比较实体标记（与If-Match相反）                |
| If-Range            | 资源未更新时发送实体Byte 的范围请求           |
| If-Unmodified_Since | 比较资源的更新时间（与If-Modified-Since相反） |
| Max-Forwards        | 最大传输逐跳数                                |
| Proxy-Authorization | 代理服务器要求客户端的认证信息                |
| Range               | 实体的字节范围请求                            |
| Referer             | 对请求中URI的原始获取方                       |
| TE                  | 传输编码的优先级                              |
| User-Agent          | HTTP客户端程序的信息                          |

#### 响应首部字段

| 首部字段名         | 说明                         |
| ------------------ | ---------------------------- |
| Accept_Ranges      | 是否接受字节范围请求         |
| Age                | 推算资源创建经过的时间       |
| ETag               | 资源匹配信息                 |
| Location           | 令客户端重定向至指定URI      |
| Proxy_Authenticate | 代理服务器对客户端的认证信息 |
| Rety-After         | 对再次发起请求的时机要求     |
| Server             | HTTP服务器的安装信息         |
| Vary               | 代理服务器缓存的管理信息     |
| WWW-Authenticate   | 服务器对客户端的认证信息     |

#### 实体首部字段

| 首部字段名       | 说明                         |
| ---------------- | ---------------------------- |
| Allow            | 资源支持的HTTP方法           |
| Content-Encoding | 实体主体适用的编码方式       |
| Content-Lanuage  | 实体主体的自然语言           |
| Content-Length   | 实体主体的大小（单位：字节） |
| Content-Location | 代替对应资源的URI            |
| Content-MD5      | 实体主体的报文摘要           |
| Content-Range    | 实体主体的位置范围           |
| Content-Type     | 实体主体的媒体类型           |
| Expires          | 实体主体过期的日期时间       |
| Last-Modified    | 资源的最后修改时间           |

### 为Cookie服务的首部字段

Cookie 的工作机制是用户识别及状态管理。Web 网站为了管理用户的状态会通过 Web 浏览器，把一些数据临时写入用户的计算机内。接着当用户访问该Web网站时，可通过通信方式取回之前发放的 Cookie。

调用 Cookie 时，由于可校验 Cookie 的有效期，以及发送方的域、路径、协议等信息，所以正规发布的 Cookie 内的数据不会因来自其他 Web 站点和攻击者的攻击而泄露。

#### 为Cookie服务的首部字段

| 首部字段名 | 说明                           | 首部类型     |
| ---------- | ------------------------------ | ------------ |
| Set-Cookie | 开始状态管理所使用的Cookie信息 | 响应首部字段 |
| Cookie     | 服务器接受到Cookie信息         | 请求首部字段 |

#### Set-Cookie字段的属性

| 属性         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| NAME=VALUE   | 赋予Cookie的名称和值（必须项）                               |
| expires=DATE | Cookie的有效期（若不明确指定则默认为浏览器关闭为止）         |
| path=PATH    | 将服务器上的文件目录作为Cookie的适用对象（若不指定则默认为文档所在的文件目录） |
| domain=域名  | 作为Cookie适用的域名（若不制定则默认为创建Cookie的服务器域名） |
| Secure       | 仅在HTTPS安全通信时才会发送Cookie                            |
| HttpOnly     | 加以限制，使Cookie不能被JavaScipty脚本访问                   |

### HTTP的缺点

* 通信使用明文（不加密），内容可能被窃听
* 不验证通信方的身份，因此有可能遭遇伪装
* 无法保证报文的完整性，所以有可能已遭篡改

### HTTP + 加密 + 认证 + 完整性保护 = HTTPS

经常会在 Web 的登录页面和购物结算界面等使用 HTTPS 通信。使用 HTTPS 通信时，不再用 http://，而是改用 https://。另外，当浏览器访问 HTTPS 通信有效的 Web 网站时，浏览器的地址栏内会出现一个带锁的标记。对 HTTPS 的显示方式会因浏览器的不同而有所改变。

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。

通常，HTTP 直接和 TCTCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披 SSL 协议这层外壳的 HTTP。

在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。

### 认证

**核对的信息举例**

* 密码：只有本人才会知道的字符串信息
* 动态令牌：仅限本人持有的设备内显示的一次性密码
* 数字证书：仅限本人（终端）持有的信息
* 生物认证：指纹和虹膜等本人的生理信息
* IC卡等：仅限本人持有的信息

#### HTTP使用的认证方式

* BASIC认证（基本认证）
* DIGEST认证（摘要认证）
* SSL客户端认证
* FormBase认证（基于表单认证）

### 基于HTTP的功能追加协议

#### HTTP的瓶颈

* 一条连接上只能发送一个请求
* 请求只能从客户端开始。客户端不可以接受除相应外的指令。
* 请求/响应首部未经压缩就发送。首部信息越多延迟越大。
* 发送冗长的首部。每次相互发送相同的首部造成的浪费较多
* 可任意选择压缩格式。非强制压缩发送。

  #### Ajax的解决方法

Ajax(Asynchronous JavaScipt and XML，异步JavaScipt与XML技术)是一种有效利用JavaScipt 和DOM(Document Object Model，文档对象模型)的操作，以达到局部Web页面替换加载的异步通信手段。和以前的通信相比，由于它只更新一部分页面，响应中传输的数据量会因此减少，这一优点显而易见。

而利用Ajax实时的从服务器获取内容，有可能导致大量请求产生。另外，Ajax仍未解决HTTP协议本身存在的问题。

#### Comet的解决方法

通常，服务端接受请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会将响应置于挂起状态，当服务器端有内容更新时，再返回响应。因此，服务器端一旦有更新，就可以立即反馈给客户端。

内容上虽让做到实时更新，但是为了保留响应，一次连接的持续时间也变长了。期间为了维持连接会消耗更多的资源。另外，Comet也未解决HTTP协议本身的问题

#### SPDY目标

处于持续开发状态的SPDY协议，正式为了在协议级别消除HTTP所遭遇的瓶颈。

#### SPDY的设计与功能

SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的应用层与运输层之间通过新加会话层的形式运作。同时，考虑到安全性问题，SPDY 规定通信中使用 SSL。

SPDY 以会话层的形式加入，控制对数据的流动，但还是采用 HTTP 建立通信连接。因此，可照常使用 HTTP 的 GET 和 POST 等方 法、Cookie 以及 HTTP 报文等。

使用SPDY后，HTTP协议额外获得以下功能：

**多路复用流**

